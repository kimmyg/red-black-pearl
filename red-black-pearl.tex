\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{graphicx}

\begin{document}

\conferenceinfo{ICFP '13}{date, Boston} 
\copyrightyear{2013} 
\copyrightdata{[to be supplied]} 

\titlebanner{Red-Black Tree Deletion}        % These are ignored unless
\preprintfooter{Presents the missing method of Okasaki's red-black trees.}   % 'preprint' option specified.

\title{Deletion: The Curse of the Red-Black Tree}
\subtitle{Functional Pearl}

\authorinfo{Kimball Germane\and Matt Might}
           {University of Utah}
           %{Email2/3}

\maketitle

\begin{abstract}
Red-black trees were born in the imperative world and only adopted into the functional. Okasaki's exposition of the simplicity of a functional implementation actually felt more like a rebirth than mere adoption. With this regime shift came a shift in focus: the energy that would otherwise have been spent on pointer manipulation is now applied to establishing correctness with formal methods--a step forward, to be sure--but one wonders if there is a simple, obviously-correct, functional delete. Indeed there is.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

\terms
red-black tree, delete, data structure

\keywords
red-black tree, delete, data structure

\section{Introduction}

When looking for a data structure to back a functional implementation of sets, red-black trees--a type of balanced binary search tree--are a natural choice. Common set operations, such as membership testing and persistent addition, map naturally to their native operations of search and insertion. And, speaking of maps, minor modifications can turn a set membership test into a map lookup operation and set addition into map extension.

The usefulness of red-black trees stems from their balanced nature. A red-black tree is a binary tree in which each node is colored red or black, and which satisfies the local property that
\begin{enumerate}
\item every red node has two black children,
\end{enumerate}
and the global property that
\begin{enumerate}
\setcounter{enumi}{1}
\item every path from the root to a leaf\footnote{For our purposes, leaf nodes do not contain data and are colored black.} node contains the same number of black nodes.
\end{enumerate}
These conditions guarantee that the longest path from root to leaf can be no more than twice the shortest (the only difference being individual red nodes interspersed along the way), and so the worst-case penalty of the search for an element in a red-black tree search is a reasonable constant factor over that of a a perfectly balanced tree.

there hasn't been a satisfactory method to delete items; enforced with types leads to Byzantine code, proven correct is good if the language is a target for extraction, but above the capabilities of typical programmers

we've encountered this situation before: Okasaki gave a functional rendition of tree insertion and a smashing intuition at the same time. the intuition, from which the code can be derived, is what we're after: we want a fairly simple, obviously correct way to perform tree deletion.

INSERTION

to review and as an example to introduce our reasoning methods, we go over insertion.

\section{Insertion}

Okasaki \cite{okasaki1999functional} made functional red-black trees accessible by presenting a clear method for element insertion by means of the recursive \texttt{insert} function and the \texttt{balance} helper function.

Using a bit of syntactic sugar on top of Racket, we can express the \texttt{insert} function with
\begin{verbatim}
(define (insert t v)
  (match t
    [(L) (R (L) v (L))]
    [(N c a x b)
     (switch-compare
       (v x)
       [< (balance (N c (insert a v) x b))]
       [= (N c a x b)]
       [> (balance (N c a x (insert b v)))])]))
\end{verbatim}
where \texttt{balance} yet remains undefined.

This definition of \texttt{insert} unilaterally colors each newly-added node red, but this may create a problem: if the parent of this new node is red, this action violates the local property. Okasaki persists in the face of this possibility, reasoning that it is easier to resolve a violation of the local property than the global one. This is achieved by the \texttt{balance} function which takes trees of one of the following four forms
\begin{center}
\includegraphics{four-cases.pdf}
\end{center}
and transforms them into
\begin{center}
\includegraphics{four-cases-resolved.pdf}
\end{center}

When performing local tree transformations, we must justify the correctness of the transformation, which entails the consideration of the local property--that red nodes must have two black children--and the global property--that every path from the root to a leaf must have the same number of black nodes.

We can verify that this transformation indeed resolves red-red violations by observing that the subtrees $a$, $b$, $c$, ande $d$ are compatible with their newly-assigned parents, no matter the colorings of their roots. However, consider the parent of each of the four cases. If the parent is red, then this transformation \emph{introduces} exactly the same kind of red-red violation it resolved!, 
We can reason about the effect this transformation has on the local property by considering the possible colorings of the root of each subtree $a$, $b$, $c$, and $d$. If the parent of this node is red, this node must be black and there are no restrictions on its placement in the reconstruction. If the parent is black, this node is possibly red, and the assignment of a red parent possibly introduces a red-red violation. The \texttt{balance} function is designed to resolve precisely this situation. We can verify this transformation preserves the global property by verifying that any possible introduction of this violation is subjected to \texttt{balance}.

Furthermore, we can reason locally about the effect this transformation has on the \emph{global} property by considering the number of black nodes this portion of the tree contributes to each path that travels through it. We can see that this transformation preserves the global property by verifying that the paths that reach the subtrees $a-d$ accumulate the same number of black nodes both before and after it occurs.

The purpose of this transformation is to resolve a violation of the local property, and while it does resolve one, it potentially introduces another further up the tree. We can treat this violation the same way and even with the same function; hence, the \texttt{balance} function is applied preventively at each level of the recursion which has the effect of working up the tree as the semantic stack unwinds. This transformation cannot possibly introduce a red-red violation at the root of the tree, being the child of no node, so the correctness of the entire process follows from a simple inductive argument.

The final stop of Okasaki's insertion algorithm is to blacken the root of the tree, which is benign in all cases. This requires a small modification of \texttt{insert} to 
\begin{verbatim}
(define (insert t v)
  (define (ins t v)
    (match t
      [(L) (R (L) v (L))]
      [(N c a x b)
       (switch-compare
         (v x)
         [< (balance (N c (insert a v) x b))]
         [= (N c a x b)]
         [> (balance (N c a x (insert b v)))])]))
  (blacken (ins t v)))
\end{verbatim}
with \texttt{blacken} given by
\begin{verbatim}
(define/match blacken
  [(N _ a x b) (N 'B a x b)])
\end{verbatim}

Our formulation of the red-black invariants allows trees to have red roots in some cases, so our root-coloring policy is more conservative, only blackening if the red-black construction demands it. This leads only to a change to \texttt{blacken}, which is now
\begin{verbatim}
(define/match blacken
  [(R (R? a) x b) (B a x b)]
  [(R a x (R? b)) (B a x b)]
  [t t])
\end{verbatim}

\section{Deletion}

the general strategy to remove items from a binary tree is to replace the item with the minimum of its right subtree and delete the node that contained that. along with the base cases, that reduces all deletion to nodes at the bottom of the tree. in a balanced binary tree, we can use this approach, but we must ensure that its particular constraints are satisfied. for a red-black tree, that means no red-red violations and to maintain the global property.

Deletion in unrestricted binary search trees is fairly straightforward. First, locate the node that contains the value to delete. If the node has no right subtree, replace it with its left subtree. Otherwise, replace its value with the minimum value of its right subtree and delete that value from the right subtree.\footnote{An alternative is to distinguish left subtrees and use the maximum element. By considering right subtrees, we get a \texttt{min-element} function for free, which is critical for priority queues.} Thus, like insertion, deletion is recursive.

By removing the minimum element from the right subtree and recurring, the algorithm repeatedly finds the leftmost node in a given subtree, and only bottoms out when that node has no right child. In an unrestricted binary search tree, this algorithm could recur on the entire tree/a lot/numerous times. The restrictions of red-black trees impose a tight bound on this algorithm's recursion depth: specifically, the global property ensures that the right subtree of
\begin{center}
\includegraphics{black-red-right-subtree-unbounded.pdf}
\end{center}
is at worst
\begin{center}
\includegraphics{black-red-right-subtree-bounded.pdf}
\end{center}
and that
\begin{center}
\includegraphics{red-black-right-subtree.pdf}
\end{center}
cannot occur. (What is my point here?)
When consideringBy applying this deletion approach to red-black trees, we reduce it to removing nodes from the tree that have at most one singleton subtree.

We will modify this general approach to account for red-black properties. The deletion algorithm proceeds by first locating the value's housing node in the tree and then removing it based on the structure of that subtree. We start by considering the configurations of a node with no right subtree from which we can extract the minimum element. These are the genuine base cases for the delete algorithm.

\begin{enumerate}
\item If the value to delete is not present in the tree, the search will terminate on an empty tree, and the value will be removed from that. This presents no difficulty: the empty tree remains unchanged after the removal of any element.
\begin{center}
\includegraphics{empty-step.pdf}
\end{center}

\item Because red nodes do not contribute to the height of the tree, we can soundly remove them from the bottom. Therefore, a single red node becomes the empty tree.
\begin{center}
\includegraphics{single-red-step.pdf}
\end{center}

\item A red node with a black-rooted left subtree
\begin{center}
\includegraphics{red-black-left-subtree.pdf}
\end{center}
violates the global property and cannot occur.

\item A black node with a red-rooted left subtree becomes the subtree itself, only black-rooted.
\begin{center}
\includegraphics{black-red-left-subtree-step.pdf}
\end{center}
The global property dictates that the left subtree is at most a single red node, so there is no chance that this introduces a global violation.

\item Finally, a black node with no left or right subtree
\begin{center}
\includegraphics{single-black.pdf}
\end{center}
presents us with a challenge. The paths that end at one of its leaves accumulate two black nodes from this portion of the tree--one for the node itself and one for the leaf. Thus, the careless excision of it would violate the global property. Repurposing some wisdom from Okasaki, perhaps we should attempt to preserve the global property at the expense of something more local. We do this by introducing the double-black color of which both branches
\begin{center}
\includegraphics{double-black-tree.pdf}
\end{center}
and leaves
\begin{center}
\includegraphics{double-black-leaf.pdf}
\end{center}
can be classified. For accounting purposes, a double-black node contributes two black nodes to any path that travels through it. With this intuition, it is obvious what a lone black node becomes after deletion. 
\begin{center}
\includegraphics{single-black-step.pdf}
\end{center}

\end{enumerate}

go over base cases, ending in black. this case is difficult because the removal of a black node alters the height of the tree--the number of black nodes in this path--and so violates the global property.

following the wisdom of Okasaki, we will take the approach of maintaining the global property at the expense of the local. we do this by temporarily introducing a double black node into the tree for accounting purposes. considering a local portion of the tree, we perform tree rotations in an attempt to discharge the black node. there are only three cases, with their reflections.

in the first case, with a red node as parent, we are able to discharge the double-black node. the inner subtree of the black node could be red, so this may introduce a local red-red violation. we have just the function to handle this in \texttt{balance}! because the parent node of this tree began as red, a balance operation will not introduce a red-red violation higher in the tree as it can with insertion. for the same reason, no violation occurs if the balance is unnecessary.

the second case is when both the parent and sibling nodes are black. in this case, we cannot discharge the black node locally and must propagate it up the tree. like the first case, we may introduce a red-red violation here, but, because of the placement of the double-black node, cannot resolve it with the \texttt{balance} function. our solution is to extend the balance function to handle a double-black root. just as with a regular black root, we have four cases to consider

cases

each of which can be resolved by transforming it into this tree.

resolved-case.

In addition to maintaining the global property and immediately resolving a local violation, there is no way that we can introduce a local violation. Furthermore, we are able to discharge the double black node by balancing!

the last case is the most complex: a black parent and a red sibling. in this case, we rely on the fact that the red sibling must have nonempty left and right subtrees, and that they must be black rooted. by also considering these nephews of the double-black node, we can discharge the double black node immediately. there is once again the possibility that we introduce a red-red violation, but it is in a subtree of the result. we cope with this by balancing this subtree during construction of the rotation.

note that if the parent or sibling node is red, the double-black node can be discharged immediately.

like the insertion algorithm, the recursive nature of delete allows us to work our way up the tree as we unwind, rotating if necessary. we might wonder if a double-black node is ever propagated to the root. if it were, the remedy would be simple: color the root node black if necessary as is done in the insertion algorithm. this is completely satisfactory, but requires us to expose the \texttt{blacken} function to the transient double-black leaf and node. in order to contain it as much as possible, we perform the dual operation when deleting as when inserting; that is, instead of blackening the root node if necessary to complete insertion, we redden the root node if possible to prepare deletion. if it is not possible, then the root node must have at least one red child, and so, in any case, there will be red slack in the tree with which to discharge the node.

CONCLUSION

Okasaki gave intuition to insertion in a functional paradigm, which made red-black trees accessible, albeit limited. A simple, intuitive, obviously correct deletion method might do the same thing and remove the limitation.



Used in this way, red-black trees are efficient, persistent, and still leave us wanting.

Deletion from red-black trees is notoriously complex. In the imperative world, programmers must contend with a bevy of cases and must concern themselves with pointer manipulation. In the functional world, that same attention is devoted to correctness whether it be enforced by types [cite Kahrs] or proved by formal methods [cite Appel]. A functional implementation of deletion from red-black trees should enjoy an intuition.







Much of the simplicity of Okasaki's explanation comes from the simplicity of going from the diagrams to
\begin{verbatim}
(define/match balance
  [(or (B (R (R a x b) y c) z d)
       (B (R a x (R b y c)) z d)
       (B a x (R (R b y c) z d))
       (B a x (R b y (R c z d))))
   (R (B a x b) y (B c z d))]
  [t t])
\end{verbatim}




%We can reason about this transformation purely locally by considering the number of black nodes this portion of the tree contributes to each path that travels through it.

%It is easy to see that this transformation brings this part of the tree in harmony with the local condition. We can reason that it preserves the global property by considering the number of black nodes this portion of the tree contributes to each path that touches it. Each of these paths a, b, c, and d passes through the single black node atop each case. Then the product of the transformation must be correct as each path inherits/accesses/utilizes one black node [in the target].

\section{Deletion}

Maybe move.

In addition to introducing a functional treatment of tree insertion, Okasaki succeeded in adding intuition to something generally considered to be intricate and error-prone. The net effect of his contribution is not code so short that it is easily memorizable but a concept so elegant and natural that, from it, the code is easily derivable--very befitting of its pearl namesake. As a result, the attitude of intricacy and proneness to error has shifted to tree deletion. While we grant that deletion seems to be more complex than insertion, we hope to show that it is only slightly so, and that, with the right intuition, it can enjoy the same status as insertion.



%Of course, we cannot let such a node persist, or we'll have no hope of maintaing optimal time complexity. We can attempt to discharge it by performing a tree rotation...

Much like insertion, we have to account for the possibility of a deletion operation introducing a double-black node from the start. Where the insertion operation balances the tree, attempting to resolve red-red violations, the deletion operation rotates the tree, attempting to discharge double-black nodes. Just as the insertion operation possibly passes unbalance up the tree, the deletion operation possibly passes a double-black node up the tree. Finally, both operations ``bottom out'' at the top of the tree, guaranteeing resolution.

The final step of Okasaki's algorithm unilaterally changes the root node to black. 

When inserting an element, our final step is to blacken the root, but only if necessary. Dual to this, when deleting an element, our \emph{first} step is to redden the root, but only if possible. This gives us slack if the ascending rotations happen to make it to the root. (If we are unable to redden the tree without violating the local condition, then at least on of the children must itself be red which puts a red node sufficiently close to the action.)

The delete function first locates the given value in recursive fashion. If we reach a leaf node, the value was not present, and the tree is left unchanged. If it is found at the bottom and colored red, it is soundly removed. If it is colored black, we replace it with a double-black leaf. If we imagine that such a leaf counts for two black nodes, thin this action preserves the global property. Of course, the properties are simply to guarantee specific time complexities, and traversing this node costs no more than traversing any other. This node is a temporary marker to indicate the need for rotation, and will be discharged accordingly.

If the value is found enough away from the fringe, we replace it with the minimum value of its right child and remove the node that contained that. This strategy is convenient for two reasons: First, it allows us to provide or leverage a \emph{min} function, which is useful when implementing priority queues. Second, it allows us to only worry about removing nodes from the bottom of the tree.

We must consider the final case when the value resides in node not on the bottom of the tree, but with no right child. In this case, the global condition constrains the node to be black and its sole child to be red. To satisfy this case, we remove the black node and replace it with its child, colored black. In doing this, we face no danger in violating either constraint.

In the same way that we consider leaf nodes to be black, we consider double-black leaf nodes to be double black.

The presence of a double-black child node indicates the need for a rotation operation. In some cases, the rotation can discharge the double-black node, and no further rotations will be made. In others, the local structure of the tree prevents resolution in its scope, and the double-black node is pushed higher to be treated by another rotation occurring higher in the tree.

We might ask whether a double black node will reach the top before resolution. Such an occurrence would not be fatal since we could soundly demote it to a single-black node once at the root. This would require a minor intrusion of concerns into the \emph{blacken} function, but is fortunately unnecessary. [Recall that] the first step of the deletion algorithm is to redden the root if possible, and that, if it's not possible, the root must have a red child. This is sufficient to guarantee that a double-black node, if it reaches the top, can be discharged there by the natural flow of the algorithm; no exceptions need be made.

In doing so, he overcame one deficiency and exposed another: the delete operation. Multiple strategies have been developed to offer the delete operation, but each has its own weakness.

Suppose we have a basic implementation of a red-black tree in a language that supports variants and pattern matching. Following Okasaki \cite{okasaki1999functional}, such an implementation might look like this:

\begin{center}
\includegraphics{BB-R-B.pdf}
\end{center}
\begin{center}
\includegraphics{BB-B-B.pdf}
\end{center}
\begin{center}
\includegraphics{four-cases-extended.pdf}
\end{center}
\begin{center}
\includegraphics{four-cases-extended-resolved.pdf}
\end{center}
\begin{center}
\includegraphics{BB-B-R.pdf}
\end{center}
\begin{verbatim}
(define/match balance
  [(or (B (R (R a x b) y c) z d)
       (B (R a x (R b y c)) z d)
       (B a x (R (R b y c) z d))
       (B a x (R b y (R c z d))))
   (R (B a x b) y (B c z d))]
  [(or (BB (R (R a x b) y c) z d)
       (BB (R a x (R b y c)) z d)
       (BB a x (R (R b y c) z d))
       (BB a x (R b y (R c z d))))
   (B (B a x b) y (B c z d))]
  [t t])
\end{verbatim}

\begin{verbatim}
(define min
  (match-lambda
    [(L) (error 'min "empty tree")]
    [(N _ (L) x _) x]
    [(N _ a _ _) (min a)]))

(define -B
  (match-lambda
    [(L2) (L)]
    [(BB a x b) (B a x b)]
    [a (error '-B "unsupported node ~a" a)]))

(define rotate
  (match-lambda
    [(R (BB? a) x (B b y c))
     (balance (B (R (-B a) x b) y c))]
    [(R (B a x b) y (BB? c))
     (balance (B a x (R b y (-B c))))]
    
    [(B (BB? a) x (B b y c))
     (balance (BB (R (-B a) x b) y c))]
    [(B (B a x b) y (BB? c))
     (balance (BB a x (R b y (-B c))))]
    
    [(B (BB? a) x (R (B b y c) z (B? d)))
     (B (balance (B (R (-B a) x b) y c)) z d)]
    [(B (R (B? a) x (B b y c)) z (BB? d))
     (B a x (balance (B b y (R c z (-B d)))))]
    
    [t t]))

(define blacken
  (match-lambda
    [(R (R? a) x b)
     (B a x b)]
    [(R a x (R? b))
     (B a x b)]
    [t t]))

(define redden
  (match-lambda
    [(B (B? a) x (B? b))
     (R a x b)]
    [t t]))

(define (delete t v cmp)
  (define (del t v cmp)
    (match t
      [(L) (L)]
      [(R (L) (== v) (L))
       (L)]
      [(B (L) (== v) (L))
       (BB)]
      [(B (R a x b) (== v) (L))
       (B a x b)]
      [(N c a x b)
       (switch-compare
        (cmp v x)
        [< (rotate (N c (del a v cmp) x b))]
        [= (let ([v (min b)])
             (rotate (N c a v (del b v cmp))))]
        [> (rotate (N c a x (del b v cmp)))])]))
  (del (redden t) v cmp))
\end{verbatim}



Red-black trees have a local [more like recursive] invariant which induces a global property.

\section{Deletion}

To support this operation, he suggests the approach of marking nodes as deleted instead of removing them from the tree outright \cite[p. 50]{okasaki1996purely}. This approach trades a rebalancing operation at removal for a global tree rebuild at time indeterminate ( and preserves time complexity only by amortizing the cost). This approach has other disadvantages. First, it contaminates the implementation: every operation needs to be taught about the deletion field and how to handle nodes so marked [, and the global rebuild condition must be tracked]. [Show example if need content.] Second, retaining references to ``deleted'' node data prevents it from being garbage-collected. [Elaborate if need content.]


%The appropriate choice of node type for a red-black tree allows it to be used for a variety of applications. (Yuck.) A singleton allows it to back mathematical sets with insert and member? operations. A pair allows it to implement dictionaries with set and lookup operations. etc. No choice of node can compensate for the lack of a remove operation.

%Removal of [Okasaki] nodes from trees can be accomplished by marking a node as deleted and deferring the actual removal to a batch removal performed when deleted nodes begin to outnumber the others. This operation gives even lower than amortized logarithmic time complexity and doesn't interfere with the complexity of other tree operations.

%What is the argument for a removal operation with immediate complexity of O(log n)?
%Okasaki's thesis, page 50 (as numbered), par. 3: this mentions the cost of marking the node as deleted, but doesn't factor it into the amortized cost, correct? If we have n nodes and "delete" n/2, that takes (n log n)/2 operations. The rebuild takes n operations. So the amortized complexity is [(n log n)/2 + n]/(n/2)=log n + 1/2, or log n. So, the complexity is the same, but there is a constant factor. What happens if we add and remove the element multiple times. The addition has an immediate complexity and so is taken care of. The deletion has an amortized complexity, but say each deleted node was added and deleted k times. Then more deletes are happening over which the n/2 cost is spread, so it's actually better.

%An immediate delete localizes the (conceptual /and/ time) complexity of the data structure. (Conceptually, because a counter needs to be kept in the other case, unless you want to incur an O(n) operation every time you want to delete.)

%A red-black tree must satisfy two invariants:



%The first invariant ensures that at most one red node can separate an otherwise parent and child. Coupled with the second invariant, we are guaranteed that the longest path from the root to an empty node is at most twice as long as the shortest path, with the difference made up by interspersed red nodes.

%There are x operations generally defined for red-black trees.

%Red-black trees are typically used as the backing store for finite subsets of 
%a totally-ordered set or finite maps with a totally-ordered domain.

%Emphasize that we would like to localize the complexity.

%If we mark nodes as deleted, every operation must know about deleted nodes.
%In order to add the delete operation [in this way], we must modify every 
%other operation.

%THIS IS BIG: real research is going to come from a question in the form of
%"prove or disprove". Being told something is true (or good) and asked to 
%justify it is going to lead to disintegrity.

%First, the implementation of a simple binary tree.


%enforcing invariants with types leads to Byz

Red-black trees were born in the imperative world and only adopted into the functional. Okasaki's exposition of the simplicity of a functional implementation actually felt more like a rebirth than mere adoption. With this regime shift came a shift in focus: the energy that would otherwise have been spent on pointer manipulation is now applied to establishing correctness with formal methods--a step forward, to be sure--but one wonders if there is a simple, obviously-correct, functional delete. Indeed there is.




Where imperative programmers devote their energies to pointer manipulation








Suppose the value we wish to delete happens to reside in a node at the bottom of the tree. There are two possibilites:

%\includegraphics[scale=0.20]{red-black-slides-008.png}

The delicate thing here is that we need to maintain the invariant that every path from the root of the tree to the bottom has the same number of black nodes. In the case that our value resides in a red node, we can intuitively see that replacing that entire subtree with a black leaf will preserve the invariant. A conceptual viewpoint that will serve us well is that the leaves donated their ``blackness'' to the parent, preserving the invariant. By applying the same idea to the second case, we must decide what happens when the ``blackness'' is propagated upward to a black node. As a conceptual convenience, we can temporarily assign the node a color of double black. This means that when counting the number of black nodes in a path which contains this node, we count this node twice. Of course, this is strictly for accounting purposes, and the node of course has the same computational cost to traverse as any other node. We will simply use this new color to account for bubbling which needs to travel up the tree.

Now we can consider the cases that the node is not at the end of the tree. First, consider the case where the node in question has only one child subtree. In order for this occur, the node would have to be black with a red child. (And we can say even more about this child: it has no children of its own, else the tree would stray from the path invariant.) The child becomes the parent and is made black. [Can we motivate this with the color arithmetic?]

learn the algorithm and then think about it.

\section{Conclusion}
It is true that genuine deletion is complex, but its complexity is fairly localized. Aside from the \texttt{delete} function proper, it requires the extension of the \texttt{Color} datatype to support two more atomic variants and a few helper functions to support color arithmetic. [It's a small price to pay.] In exchange, we receive O(log n) direct time complexity without any additional constant factor above the original implementation.



\appendix
\section{Appendix Title}

This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}
\bibliography{red-black-pearl}

% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright

\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
P. Q. Smith, and X. Y. Jones. ...reference text...

\end{thebibliography}

\end{document}







